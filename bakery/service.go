package bakery

// Service represents a service which can delegate
// authorization checks to other services,
// and may also be used as a delegation endpoint
// to discharge authorization checks from other services.
type Service struct {
	store Storage
	checker FirstPartyChecker
	caveatIdMaker CaveatIdMaker

	// mu guards the fields following it.
	mu sync.Mutex

	// thirdParty maps client ids to the third-party
	// caveat ids cached for those clients.
	//
	// TODO(rog) we could potentially use
	// external storage for this so that clients
	// could use cached ids even when going to
	// one of several different servers.
	thirdPartyCaveats map[string] *thirdPartyCaveatCache
}

// NewService returns a service which stores its macaroons
// in the given storage. The given checker function is
// used to check the validity of caveats. Macaroons
// generated by the service will be associated with the
// given location.
func NewService(
		location string,
		store Storage,
		checker FirstPartyChecker,
		caveatIdMaker CaveatIdMaker,
) *Service {
	return &Service{
		store: storage{store},
		checker: checker,
		caveatIdMaker: caveatIdMaker,
		thirdPartyCaveats: make(map[string] *thirdPartyCaveatCache),
	}
}

// CaveatIdMaker can create caveat ids for
// third parties. It is left abstract to allow location-dependent
// caveat id creation.
type CaveatIdMaker interface {
	NewCaveatId(caveat Caveat) (string, error)
}

// Checker returns the checker used by the service.
func (svc *Service) Checker() FirstPartyChecker {
	return svc.checker
}

// Caveat represents a condition that must be true for a check to
// complete successfully. If Location is non-empty, the caveat must be
// discharged by a third party at the given location, which should be a
// fully qualified URL that refers to a service which implements the
// name space implemented by Service.DischargeHandler.
type Caveat struct {
	Location  string
	Condition string
}

// Capability represents a client capability. A client
// can gain a capability by presenting a valid, fully
// discharged macaroon that is associated with
// the capability.
type Capability struct {
	// Id holds the capability identifier. This
	// should describe the capability in question.
	Id string

	// Caveats holds the list of caveats that must
	// hold for the capability to be granted.
	Caveats []Caveat
}

// Request represents a request made to a service
// by a client. The request may be long-lived. It holds a set
// of macaroons that the client wishes to be taken
// into account.
//
// Methods on a Request may be called concurrently
// with each other.
type Request struct {
	svc *Service
	checker FirstPartyChecker
	clientId string

	mu sync.Mutex
	macaroons []*macaroon.Macaroon

	// inStorage maps from macaroon id
	// to the storage associated with that macaroon
	// for all elements in macaroons.
	inStorage map[*macaroon.Macaroon] *storageItem

	// capability maps from a capability id to the macaroons
	// in the request that may discharge that capability.
	capability map[string] []*macaroon.Macaroon

	// verified holds the verified status of the macaroon
	// requests. Items not in the map have not yet
	// been verified either way.
	verified map[*macaroon.Macaroon] error
}

// NewRequest returns a new client request object that uses checker to
// verify caveats. If checker is nil, the service's checker will be
// used. The clientId, if non-empty, will be used to associate
// the request with others with the same id - third party
// caveats will be shared between requests with the same clientId,
// allowing a given client to cache them.
func (svc *Service) NewRequest(clientId string, checker FirstPartyChecker) *Request {
	return &Request{
		svc: svc,
		checker: checker,
		clientId: clientId,
		inStorage: make(map[string] *storageItem),
		capability: map[string] []*macaroon.Macaroon,
	}
}

// AddClientMacaroon associates the given macaroon  with
// the request. The macaroon will be taken into account when req.Check
// is called.
func (req *Request) AddClientMacaroon(m *macaroon.Macaroon) {
	req.mu.Lock()
	defer req.mu.Unlock()

	req.macaroons = append(req.macaroons, m)
	if m.inStorage[m] != nil {
		return
	}
	item, err := req.svc.store.Get(m.Id())
	if err == ErrNotFound {
		return
	}
	if err != nil {
		log.Printf("warning: failed to read storage: %v", err)
		return
	}
	req.inStorage[m] = item
	req.capability[item.Capability] = append(req.capability[item.Capability], m)
}

// Check checks whether the given caveats hold true. If they do not hold
// true because some third party caveat is not available, CheckCaveats
// returns a DischargeRequiredError holding a macaroon that must be
// discharged for the given caveats to be fulfilled.
func (req *Request) Check(capability *Capability) error {
	req.mu.Lock()
	defer req.mu.Unlock()

	err := req.check(capability.Id)
	if err == nil {
		return nil
	}
	rootKey, err := randomBytes(24)
	if err != nil {
		return fmt.Errorf("cannot generate root key for new macaroon: %v", err)
	}
	id, err := randomBytes(24)
	if err != nil {
		return fmt.Errorf("cannot generate id for new macaroon: %v", err)
	}

	m := macaroon.New(rootKey, id, req.svc.location)
	for _, cav := range capability.Caveats {
		if cav.Location == "" {
			m.AddFirstPartyCaveat(cav.Condition)
			continue
		}
		id, err := req.svc.caveatIdMaker.NewCaveatId(cav)
		if err != nil {
			return fmt.Errorf("cannot create third party caveat id at %q: %v", cav.Location, err)
		}
		if err := m.AddThirdPartyCaveat(id, cav.Location); err != nil {
			return fmt.Errorf("cannot add third party caveat: %v", err)
		}
	}
	// TODO(rog) add original error from check to the returned error.
	return &DischargeRequiredError{m}
}

func randomBytes(n int) (byte, error) {
	b := make([]byte, n)
	_, err := rand.Read(b)
	if err != nil {
		return fmt.Errorf("cannot generate %d random bytes: %v", n, err)
	}
	return nil
}

func (req *request) check(capability *Capability) error {
	possibleMacaroons := req.capability[capability.Id]
	if len(possibleMacaroons) == 0 {
		// no macaroons discharging the capability.
		return fmt.Errorf("no possible macaroons found")
	}

	// TODO consider making it possible to run verifications
	// concurrently (possibly using something like single-flight).

	var anError error
	for _, m := range possibleMacaroons {
		item := req.inStorage[m]
		err := m.Verify(item.RootKey, req.checker.CheckFirstPartyCaveat, req.macaroons)
		if err == nil {
			return nil
		}
		anError = err
	}
	return anError
}

// DischargeRequiredError represents an error that occurs
// when an operation requires permissions which are not
// available. The Macaroon field holds a macaroon which
// must be discharged for the original operation to succeed.
type DischargeRequiredError struct {
	Macaroon *macaroon.Macaroon
}

// TODO(rog) consider possible options for checkers:
// - first and third party checkers could be merged, but
// then there would have to be a runtime check
// that when used to check first-party caveats, the
// checker does not return third-party caveats.

// ThirdPartyChecker holds a function that checks
// third party caveats for validity. It the
// caveat is valid, it returns a nil error and
// optionally a slice of extra caveats that
// will be added to the discharge macaroon.
//
// If the caveat kind was not recognised, the checker
// should return ErrCaveatNotRecognised.
type ThirdPartyChecker interface {
	CheckThirdPartyCaveat(caveat string) ([]Caveat, error)
}

// FirstPartyChecker holds a function that checks
// first party caveats for validity.
//
// If the caveat kind was not recognised, the checker
// should return ErrCaveatNotRecognised.
type FirstPartyChecker interface {
	CheckFirstPartyCaveat(caveat string) error
}

type FirstPartyCheckerFunc func(caveat string) error

func (c FirstPartyCheckerFunc) CheckFirstPartyCaveat(caveat string) error {
	return c(caveat)
}

var ErrCaveatNotRecognized = "caveat not recogniz.ed"

// thirdPartyCaveatCache holds a client-specific cache
// of caveat ids.
// TODO(rog) figure out how to expire entries from
// this cache (perhaps time-expire entries based on
// the expiry date of the macroon that includes the
// third-party caveat)
type thirdPartyCaveatCache struct {
	// caveats maps from caveat to caveat id.
	caveats map[Caveat] string
}

func (c *thirdPartyCaveatCache) get(cav Caveat) string {
	return c.caveats[cav]
}

func (c *thirdPartyCaveatCache) put(cav Caveat, caveatId string) {
	c.caveats[cav] = caveatId
}

type byCaveatCost []Caveat

func (c byCaveatCost) Less(i, j int) bool {
	// TODO(rog) more cost criteria?
	iHasLoc, jHasLoc := c[i].Location != "", c[j].Location != ""
	if iHasLoc != jHasLoc {
		return !iHasLoc
	}
	return false
}

func (c byCaveatCost) Swap(i, j int) {
	c[i], c[j] = c[j], c[i]
}

func (c byCaveatCost) Len() int {
	return len(c)
}